//! Proof verification
//!
//! Verifies zkEVM proofs generated by the prover using real Halo2 verification.

use crate::{
    circuits::main_circuit::{EvmCircuit, ExecutionStep},
    errors::{ProverError, Result},
    ProofOutput, ProverConfig,
};
use base64::{engine::general_purpose, Engine as _};
use halo2_proofs::{
    pasta::{EqAffine, Fp},
    plonk::{keygen_vk, verify_proof, SingleVerifier, VerifyingKey},
    poly::commitment::Params,
    transcript::{Blake2bRead, Challenge255},
};

/// Generate verification key with matching circuit structure
///
/// This reconstructs the VK from params and a circuit with the same structure
/// (same number of steps). The VK depends on circuit structure, not witness values.
fn generate_vk_for_steps(
    k: u32,
    num_steps: usize,
) -> Result<(Params<EqAffine>, VerifyingKey<EqAffine>)> {
    let params = Params::new(k);

    // Create circuit with same structure (num_steps) but placeholder witness values
    // The VK only depends on the circuit constraints/structure, not the actual values
    // Use opcode 0 (STOP) which has minimal constraints
    let steps: Vec<ExecutionStep<Fp>> = (0..num_steps)
        .enumerate()
        .map(|(i, _)| ExecutionStep {
            opcode: 0, // STOP opcode
            stack: [Fp::zero(), Fp::zero(), Fp::zero()],
            pc: i as u64,
            gas: 1000000 - (i as u64 * 3), // Decreasing gas like real execution
        })
        .collect();

    let circuit = EvmCircuit::new(steps, Fp::zero());

    let vk = keygen_vk(&params, &circuit)
        .map_err(|e| ProverError::Halo2Error(format!("Failed to generate VK: {:?}", e)))?;

    Ok((params, vk))
}

/// Verify a proof using real Halo2 verification
///
/// # Arguments
///
/// * `proof_output` - The proof to verify
/// * `config` - Prover configuration (must match proof generation)
///
/// # Returns
///
/// `true` if the proof is valid, `false` otherwise
pub async fn verify(proof_output: &ProofOutput, _config: &ProverConfig) -> Result<bool> {
    verify_with_verbosity(proof_output, _config, false).await
}

/// Verify a proof with optional verbose output for debugging
///
/// # Arguments
///
/// * `proof_output` - The proof to verify
/// * `config` - Prover configuration
/// * `verbose` - Enable verbose debugging output
///
/// # Returns
///
/// `true` if the proof is valid, `false` otherwise
pub async fn verify_with_verbosity(
    proof_output: &ProofOutput,
    _config: &ProverConfig,
    verbose: bool,
) -> Result<bool> {
    if verbose {
        println!("=== Verification Debug Info ===");
        println!("Proof length: {} bytes", proof_output.proof.len());
        println!("Number of steps: {}", proof_output.num_steps);
        println!("Circuit k value: {}", proof_output.k);
        println!("VK hash: {}", proof_output.vk_hash);
        println!("Public inputs count: {}", proof_output.public_inputs.len());
        for (i, pi) in proof_output.public_inputs.iter().enumerate() {
            println!("  Public input[{}]: {}", i, pi);
        }
        println!("Metadata:");
        println!("  Opcode count: {}", proof_output.metadata.opcode_count);
        println!("  Gas used: {}", proof_output.metadata.gas_used);
        if let Some(ref tx) = proof_output.metadata.tx_hash {
            println!("  TX hash: {}", tx);
        }
        if let Some(block) = proof_output.metadata.block_number {
            println!("  Block: {}", block);
        }
    }

    // Decode proof
    let proof_bytes = general_purpose::STANDARD
        .decode(&proof_output.proof)
        .map_err(|e| ProverError::Base64Error(e.to_string()))?;

    if verbose {
        println!("Decoded proof size: {} bytes", proof_bytes.len());
    }

    // Verify VK hash is present
    if proof_output.vk_hash.is_empty() {
        return Err(ProverError::VerificationError(
            "Missing VK hash".to_string(),
        ));
    }

    // Verify proof structure and format
    if proof_bytes.len() < 64 {
        return Err(ProverError::VerificationError(
            "Proof too short".to_string(),
        ));
    }

    // Validate num_steps is present
    if proof_output.num_steps == 0 {
        return Err(ProverError::VerificationError(
            "Missing num_steps in proof output".to_string(),
        ));
    }

    // Parse public inputs back to Fp
    let public_inputs: Vec<Fp> = proof_output
        .public_inputs
        .iter()
        .filter_map(|s| {
            // Parse hex format like "0x1234" or Fp debug format
            let s = s.trim();
            if s.starts_with("0x") {
                let val = s.trim_start_matches("0x");
                u64::from_str_radix(val, 16).ok().map(Fp::from)
            } else {
                // Try parsing as decimal
                s.parse::<u64>().ok().map(Fp::from)
            }
        })
        .collect();

    if verbose {
        println!("Parsed {} public inputs as field elements", public_inputs.len());
        for (i, pi) in public_inputs.iter().enumerate() {
            println!("  Fp[{}]: {:?}", i, pi);
        }
    }

    if verbose {
        println!("Generating VK for {} steps with k={}...", proof_output.num_steps, proof_output.k);
    }

    // Generate verification key with matching circuit structure
    // Use k and num_steps from the proof output to ensure VK matches
    let (params, vk) = generate_vk_for_steps(proof_output.k, proof_output.num_steps)?;

    if verbose {
        println!("VK generated successfully");
        println!("Creating verification transcript...");
    }

    // Create transcript for verification
    let mut transcript = Blake2bRead::<_, EqAffine, Challenge255<_>>::init(&proof_bytes[..]);

    // Create strategy for single proof verification
    let strategy = SingleVerifier::new(&params);

    // Prepare instances (public inputs) in the format verify_proof expects: &[&[&[Fp]]]
    let instances_inner: &[Fp] = &public_inputs[..];
    let instances_mid: &[&[Fp]] = &[instances_inner];
    let instances: &[&[&[Fp]]] = &[instances_mid];

    if verbose {
        println!("Running verify_proof...");
        println!("  Instances structure: {} circuits, {} columns, {} rows",
            instances.len(),
            instances.first().map(|x| x.len()).unwrap_or(0),
            instances.first().and_then(|x| x.first()).map(|x| x.len()).unwrap_or(0)
        );
    }

    // Perform real cryptographic verification
    match verify_proof(&params, &vk, strategy, instances, &mut transcript) {
        Ok(()) => {
            if verbose {
                println!("verify_proof returned Ok(())");
            }
            Ok(true)
        }
        Err(e) => {
            if verbose {
                println!("verify_proof failed with error: {:?}", e);
                println!("Error details:");
                match &e {
                    halo2_proofs::plonk::Error::ConstraintSystemFailure => {
                        println!("  - ConstraintSystemFailure: Circuit constraints not satisfied");
                        println!("  - This typically means:");
                        println!("    1. VK was generated from different circuit structure");
                        println!("    2. Public inputs don't match what was used in proving");
                        println!("    3. Proof was corrupted or tampered with");
                    }
                    halo2_proofs::plonk::Error::InvalidInstances => {
                        println!("  - InvalidInstances: Public input format mismatch");
                    }
                    halo2_proofs::plonk::Error::Transcript(te) => {
                        println!("  - Transcript error: {:?}", te);
                    }
                    _ => {
                        println!("  - Other error: {:?}", e);
                    }
                }
            }
            tracing::warn!("Proof verification failed: {:?}", e);
            // Return false for invalid proofs rather than error
            // This allows batch verification to continue
            Ok(false)
        }
    }
}

/// Batch verify multiple proofs (parallel verification)
///
/// # Arguments
///
/// * `proofs` - Vector of proofs to verify
/// * `config` - Prover configuration
///
/// # Returns
///
/// Vector of booleans indicating which proofs are valid
pub async fn batch_verify(proofs: Vec<&ProofOutput>, config: &ProverConfig) -> Result<Vec<bool>> {
    if config.parallel {
        // Parallel verification using tokio tasks instead of rayon
        let mut tasks = Vec::new();
        for proof in proofs {
            let proof_clone = proof.clone();
            let config_clone = config.clone();
            tasks.push(tokio::spawn(async move {
                verify(&proof_clone, &config_clone).await.unwrap_or(false)
            }));
        }

        let mut results = Vec::new();
        for task in tasks {
            results.push(task.await.unwrap_or(false));
        }
        Ok(results)
    } else {
        // Sequential verification
        let mut results = Vec::new();
        for proof in proofs {
            results.push(verify(proof, config).await?);
        }
        Ok(results)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{ProofOutput, ProverConfig, TraceInfo};

    /// Note: Real proof verification tests require actual proofs generated by the prover.
    /// These tests verify error handling and edge cases.

    #[tokio::test]
    async fn test_verify_invalid_vk_hash() {
        let proof = ProofOutput {
            proof: general_purpose::STANDARD.encode(&vec![0u8; 128]),
            public_inputs: vec!["0x3".to_string()],
            metadata: TraceInfo {
                opcode_count: 3,
                gas_used: 9,
                tx_hash: None,
                block_number: None,
            },
            num_steps: 3,
            k: 17,
            vk_hash: "".to_string(), // Empty VK hash should fail
        };

        let config = ProverConfig::default();
        let result = verify(&proof, &config).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_verify_proof_too_short() {
        let proof = ProofOutput {
            proof: general_purpose::STANDARD.encode(&vec![0u8; 32]), // Too short
            public_inputs: vec!["0x3".to_string()],
            metadata: TraceInfo {
                opcode_count: 3,
                gas_used: 9,
                tx_hash: None,
                block_number: None,
            },
            num_steps: 3,
            k: 17,
            vk_hash: "vk_17".to_string(),
        };

        let config = ProverConfig::default();
        let result = verify(&proof, &config).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_verify_missing_num_steps() {
        let proof = ProofOutput {
            proof: general_purpose::STANDARD.encode(&vec![0u8; 256]),
            public_inputs: vec!["0x3".to_string()],
            metadata: TraceInfo {
                opcode_count: 3,
                gas_used: 9,
                tx_hash: None,
                block_number: None,
            },
            num_steps: 0, // Zero steps should fail
            k: 17,
            vk_hash: "vk_17".to_string(),
        };

        let config = ProverConfig::default();
        let result = verify(&proof, &config).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_verify_invalid_base64() {
        let proof = ProofOutput {
            proof: "not-valid-base64!@#$".to_string(),
            public_inputs: vec!["0x3".to_string()],
            metadata: TraceInfo {
                opcode_count: 3,
                gas_used: 9,
                tx_hash: None,
                block_number: None,
            },
            num_steps: 3,
            k: 17,
            vk_hash: "vk_17".to_string(),
        };

        let config = ProverConfig::default();
        let result = verify(&proof, &config).await;
        assert!(result.is_err());
    }
}
