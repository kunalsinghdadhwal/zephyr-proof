//! Proof verification
//!
//! Verifies zkEVM proofs generated by the prover.

use crate::{
    ProofOutput, ProverConfig,
    circuits::{EvmCircuit, ExecutionStep},
    errors::{ProverError, Result},
};
use base64::{Engine as _, engine::general_purpose};
use halo2_proofs::{dev::MockProver, pasta::Fp};

/// Verify a proof
///
/// # Arguments
///
/// * `proof_output` - The proof to verify
/// * `config` - Prover configuration (must match proof generation)
///
/// # Returns
///
/// `true` if the proof is valid, `false` otherwise
pub async fn verify(proof_output: &ProofOutput, config: &ProverConfig) -> Result<bool> {
    // Decode proof
    let proof_bytes = general_purpose::STANDARD
        .decode(&proof_output.proof)
        .map_err(|e| ProverError::Base64Error(e.to_string()))?;

    // Verify VK hash matches
    let expected_vk_hash = format!("vk_{}", config.k);
    if proof_output.vk_hash != expected_vk_hash {
        return Err(ProverError::VerificationError(
            "VK hash mismatch".to_string(),
        ));
    }

    // Parse public inputs
    let public_inputs: Vec<Fp> = proof_output
        .public_inputs
        .iter()
        .map(|s| {
            // Simple parsing for mock format (real impl would use proper deserialization)
            let val = s.trim_matches(|c| c == '0' || c == 'x');
            Fp::from(val.parse::<u64>().unwrap_or(0))
        })
        .collect();

    // For MVP, we just verify the proof was properly formatted
    // Real impl would use verify_proof with VerifyingKey
    if proof_bytes.len() < 64 {
        return Err(ProverError::VerificationError(
            "Proof too short".to_string(),
        ));
    }

    // Mock verification always passes for valid format
    // TODO: Implement real verification:
    // 1. Load VerifyingKey from vk_hash
    // 2. Call verify_proof(vk, params, public_inputs, proof_bytes)
    // 3. Return true/false based on result

    Ok(true)
}

/// Batch verify multiple proofs (parallel verification)
///
/// # Arguments
///
/// * `proofs` - Vector of proofs to verify
/// * `config` - Prover configuration
///
/// # Returns
///
/// Vector of booleans indicating which proofs are valid
pub async fn batch_verify(proofs: Vec<&ProofOutput>, config: &ProverConfig) -> Result<Vec<bool>> {
    use rayon::prelude::*;

    if config.parallel {
        // Parallel verification
        let results: Vec<_> = proofs
            .par_iter()
            .map(|proof| {
                tokio::runtime::Handle::current()
                    .block_on(verify(proof, config))
                    .unwrap_or(false)
            })
            .collect();
        Ok(results)
    } else {
        // Sequential verification
        let mut results = Vec::new();
        for proof in proofs {
            results.push(verify(proof, config).await?);
        }
        Ok(results)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{ProofOutput, TraceInfo};

    #[tokio::test]
    async fn test_verify_valid_proof() {
        let proof = ProofOutput {
            proof: general_purpose::STANDARD.encode(&vec![0u8; 128]),
            public_inputs: vec!["0x3".to_string()],
            metadata: TraceInfo {
                opcode_count: 3,
                gas_used: 9,
                tx_hash: None,
                block_number: None,
            },
            vk_hash: "vk_17".to_string(),
        };

        let config = ProverConfig::default();
        let result = verify(&proof, &config).await;
        assert!(result.is_ok());
        assert!(result.unwrap());
    }

    #[tokio::test]
    async fn test_verify_invalid_vk_hash() {
        let proof = ProofOutput {
            proof: general_purpose::STANDARD.encode(&vec![0u8; 128]),
            public_inputs: vec!["0x3".to_string()],
            metadata: TraceInfo {
                opcode_count: 3,
                gas_used: 9,
                tx_hash: None,
                block_number: None,
            },
            vk_hash: "wrong_vk".to_string(),
        };

        let config = ProverConfig::default();
        let result = verify(&proof, &config).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_batch_verify() {
        let proof1 = ProofOutput {
            proof: general_purpose::STANDARD.encode(&vec![0u8; 128]),
            public_inputs: vec!["0x3".to_string()],
            metadata: TraceInfo {
                opcode_count: 3,
                gas_used: 9,
                tx_hash: None,
                block_number: None,
            },
            vk_hash: "vk_17".to_string(),
        };

        let proof2 = proof1.clone();

        let config = ProverConfig::default();
        let results = batch_verify(vec![&proof1, &proof2], &config).await;
        assert!(results.is_ok());
        assert_eq!(results.unwrap(), vec![true, true]);
    }
}
