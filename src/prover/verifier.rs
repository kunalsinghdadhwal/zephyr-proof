//! Proof verification
//!
//! Verifies zkEVM proofs generated by the prover using real Halo2 verification.

use crate::{
    circuits::main_circuit::{EvmCircuit, ExecutionStep},
    errors::{ProverError, Result},
    ProofOutput, ProverConfig,
};
use base64::{engine::general_purpose, Engine as _};
use halo2_proofs::{
    pasta::{EqAffine, Fp},
    plonk::{keygen_vk, verify_proof, SingleVerifier, VerifyingKey},
    poly::commitment::Params,
    transcript::{Blake2bRead, Challenge255},
};

/// Generate verification key for verification
///
/// This reconstructs the VK from params and an empty circuit.
/// In production, VK would be cached or serialized.
fn generate_vk(k: u32) -> Result<(Params<EqAffine>, VerifyingKey<EqAffine>)> {
    let params = Params::new(k);

    // Create an empty circuit with placeholder steps for VK generation
    let steps = vec![ExecutionStep {
        opcode: 0,
        stack: [Fp::from(0u64), Fp::from(0u64), Fp::from(0u64)],
        pc: 0,
        gas: 0,
    }];
    let circuit = EvmCircuit::new(steps, Fp::from(0u64));

    let vk = keygen_vk(&params, &circuit)
        .map_err(|e| ProverError::Halo2Error(format!("Failed to generate VK: {:?}", e)))?;

    Ok((params, vk))
}

/// Verify a proof using real Halo2 verification
///
/// # Arguments
///
/// * `proof_output` - The proof to verify
/// * `config` - Prover configuration (must match proof generation)
///
/// # Returns
///
/// `true` if the proof is valid, `false` otherwise
pub async fn verify(proof_output: &ProofOutput, config: &ProverConfig) -> Result<bool> {
    // Decode proof
    let proof_bytes = general_purpose::STANDARD
        .decode(&proof_output.proof)
        .map_err(|e| ProverError::Base64Error(e.to_string()))?;

    // Verify VK hash is present
    if proof_output.vk_hash.is_empty() {
        return Err(ProverError::VerificationError(
            "Missing VK hash".to_string(),
        ));
    }

    // Verify proof structure and format
    if proof_bytes.len() < 64 {
        return Err(ProverError::VerificationError(
            "Proof too short".to_string(),
        ));
    }

    // Parse public inputs back to Fp
    let public_inputs: Vec<Fp> = proof_output
        .public_inputs
        .iter()
        .filter_map(|s| {
            // Parse hex format like "0x1234" or Fp debug format
            let s = s.trim();
            if s.starts_with("0x") {
                let val = s.trim_start_matches("0x");
                u64::from_str_radix(val, 16).ok().map(Fp::from)
            } else {
                // Try parsing as decimal
                s.parse::<u64>().ok().map(Fp::from)
            }
        })
        .collect();

    // Generate verification key (in production, this would be cached/loaded)
    let (params, vk) = generate_vk(config.k)?;

    // Create transcript for verification
    let mut transcript = Blake2bRead::<_, EqAffine, Challenge255<_>>::init(&proof_bytes[..]);

    // Create strategy for single proof verification
    let strategy = SingleVerifier::new(&params);

    // Prepare instances (public inputs) in the format verify_proof expects: &[&[&[Fp]]]
    let instances_inner: &[Fp] = &public_inputs[..];
    let instances_mid: &[&[Fp]] = &[instances_inner];
    let instances: &[&[&[Fp]]] = &[instances_mid];

    // Perform real cryptographic verification
    match verify_proof(&params, &vk, strategy, instances, &mut transcript) {
        Ok(()) => Ok(true),
        Err(e) => {
            tracing::warn!("Proof verification failed: {:?}", e);
            // Return false for invalid proofs rather than error
            // This allows batch verification to continue
            Ok(false)
        }
    }
}

/// Batch verify multiple proofs (parallel verification)
///
/// # Arguments
///
/// * `proofs` - Vector of proofs to verify
/// * `config` - Prover configuration
///
/// # Returns
///
/// Vector of booleans indicating which proofs are valid
pub async fn batch_verify(proofs: Vec<&ProofOutput>, config: &ProverConfig) -> Result<Vec<bool>> {
    if config.parallel {
        // Parallel verification using tokio tasks instead of rayon
        let mut tasks = Vec::new();
        for proof in proofs {
            let proof_clone = proof.clone();
            let config_clone = config.clone();
            tasks.push(tokio::spawn(async move {
                verify(&proof_clone, &config_clone).await.unwrap_or(false)
            }));
        }

        let mut results = Vec::new();
        for task in tasks {
            results.push(task.await.unwrap_or(false));
        }
        Ok(results)
    } else {
        // Sequential verification
        let mut results = Vec::new();
        for proof in proofs {
            results.push(verify(proof, config).await?);
        }
        Ok(results)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{ProofOutput, TraceInfo};

    #[tokio::test]
    async fn test_verify_valid_proof() {
        use halo2_proofs::pasta::Fp;
        use sha2::{Digest, Sha256};

        // Create a valid proof structure - must match verifier's parsing
        let public_inputs_str = vec!["0x7b".to_string()]; // 123 in hex

        // Parse exactly as the verifier does
        let public_inputs_fp: Vec<Fp> = public_inputs_str
            .iter()
            .map(|s| {
                let val = s.trim_matches(|c| c == '0' || c == 'x');
                Fp::from(val.parse::<u64>().unwrap_or(0))
            })
            .collect();

        // Generate expected hash
        let mut hasher = Sha256::new();
        for input in &public_inputs_fp {
            hasher.update(format!("{:?}", input).as_bytes());
        }
        let hash = hasher.finalize();

        // Create proof with hash
        let mut proof_bytes = vec![0u8; 256];
        proof_bytes[..32].copy_from_slice(&hash);

        let proof = ProofOutput {
            proof: general_purpose::STANDARD.encode(&proof_bytes),
            public_inputs: public_inputs_str,
            metadata: TraceInfo {
                opcode_count: 3,
                gas_used: 9,
                tx_hash: None,
                block_number: None,
            },
            vk_hash: "vk_17".to_string(),
        };

        let config = ProverConfig::default();
        let result = verify(&proof, &config).await;
        assert!(result.is_ok());
        assert!(result.unwrap());
    }

    #[tokio::test]
    async fn test_verify_invalid_vk_hash() {
        let proof = ProofOutput {
            proof: general_purpose::STANDARD.encode(&vec![0u8; 128]),
            public_inputs: vec!["0x3".to_string()],
            metadata: TraceInfo {
                opcode_count: 3,
                gas_used: 9,
                tx_hash: None,
                block_number: None,
            },
            vk_hash: "".to_string(), // Empty VK hash should fail
        };

        let config = ProverConfig::default();
        let result = verify(&proof, &config).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_verify_proof_too_short() {
        let proof = ProofOutput {
            proof: general_purpose::STANDARD.encode(&vec![0u8; 32]), // Too short
            public_inputs: vec!["0x3".to_string()],
            metadata: TraceInfo {
                opcode_count: 3,
                gas_used: 9,
                tx_hash: None,
                block_number: None,
            },
            vk_hash: "vk_17".to_string(),
        };

        let config = ProverConfig::default();
        let result = verify(&proof, &config).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_batch_verify() {
        use halo2_proofs::pasta::Fp;
        use sha2::{Digest, Sha256};

        let public_inputs_str = vec!["0x3".to_string()];

        // Parse exactly as the verifier does
        let public_inputs_fp: Vec<Fp> = public_inputs_str
            .iter()
            .map(|s| {
                let val = s.trim_matches(|c| c == '0' || c == 'x');
                Fp::from(val.parse::<u64>().unwrap_or(0))
            })
            .collect();

        let mut hasher = Sha256::new();
        for input in &public_inputs_fp {
            hasher.update(format!("{:?}", input).as_bytes());
        }
        let hash = hasher.finalize();

        let mut proof_bytes = vec![0u8; 256];
        proof_bytes[..32].copy_from_slice(&hash);

        let proof1 = ProofOutput {
            proof: general_purpose::STANDARD.encode(&proof_bytes),
            public_inputs: public_inputs_str.clone(),
            metadata: TraceInfo {
                opcode_count: 3,
                gas_used: 9,
                tx_hash: None,
                block_number: None,
            },
            vk_hash: "vk_17".to_string(),
        };

        let proof2 = proof1.clone();

        let config = ProverConfig::default();
        let results = batch_verify(vec![&proof1, &proof2], &config).await;
        assert!(results.is_ok());
        assert_eq!(results.unwrap(), vec![true, true]);
    }

    #[tokio::test]
    async fn test_batch_verify_sequential() {
        use halo2_proofs::pasta::Fp;
        use sha2::{Digest, Sha256};

        let public_inputs_fp = vec![Fp::from(5u64)];
        let mut hasher = Sha256::new();
        for input in &public_inputs_fp {
            hasher.update(format!("{:?}", input).as_bytes());
        }
        let hash = hasher.finalize();

        let mut proof_bytes = vec![0u8; 256];
        proof_bytes[..32].copy_from_slice(&hash);

        let proof = ProofOutput {
            proof: general_purpose::STANDARD.encode(&proof_bytes),
            public_inputs: vec!["0x5".to_string()],
            metadata: TraceInfo {
                opcode_count: 2,
                gas_used: 6,
                tx_hash: None,
                block_number: None,
            },
            vk_hash: "vk_17".to_string(),
        };

        let config = ProverConfig {
            parallel: false,
            ..Default::default()
        };

        let results = batch_verify(vec![&proof], &config).await;
        assert!(results.is_ok());
    }

    #[tokio::test]
    async fn test_verify_invalid_base64() {
        let proof = ProofOutput {
            proof: "not-valid-base64!@#$".to_string(),
            public_inputs: vec!["0x3".to_string()],
            metadata: TraceInfo {
                opcode_count: 3,
                gas_used: 9,
                tx_hash: None,
                block_number: None,
            },
            vk_hash: "vk_17".to_string(),
        };

        let config = ProverConfig::default();
        let result = verify(&proof, &config).await;
        assert!(result.is_err());
    }
}
