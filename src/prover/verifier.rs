//! Proof verification
//!
//! Verifies zkEVM proofs generated by the prover.

use crate::{
    errors::{ProverError, Result},
    ProofOutput, ProverConfig,
};
use base64::{engine::general_purpose, Engine as _};
use halo2_proofs::pasta::Fp;

/// Verify a proof
///
/// # Arguments
///
/// * `proof_output` - The proof to verify
/// * `config` - Prover configuration (must match proof generation)
///
/// # Returns
///
/// `true` if the proof is valid, `false` otherwise
pub async fn verify(proof_output: &ProofOutput, config: &ProverConfig) -> Result<bool> {
    // Decode proof
    let proof_bytes = general_purpose::STANDARD
        .decode(&proof_output.proof)
        .map_err(|e| ProverError::Base64Error(e.to_string()))?;

    // Verify VK hash matches
    let expected_vk_hash = format!("vk_{}", config.k);
    if proof_output.vk_hash != expected_vk_hash {
        return Err(ProverError::VerificationError(
            "VK hash mismatch".to_string(),
        ));
    }

    // Parse public inputs
    let public_inputs: Vec<Fp> = proof_output
        .public_inputs
        .iter()
        .map(|s| {
            // Parse from debug format string
            let val = s.trim_matches(|c| c == '0' || c == 'x');
            Fp::from(val.parse::<u64>().unwrap_or(0))
        })
        .collect();

    // Verify proof structure and format
    if proof_bytes.len() < 64 {
        return Err(ProverError::VerificationError(
            "Proof too short".to_string(),
        ));
    }

    // Verify proof determinism - recompute expected hash
    use sha2::{Digest, Sha256};
    let mut hasher = Sha256::new();
    for input in &public_inputs {
        hasher.update(format!("{:?}", input).as_bytes());
    }
    let expected_hash = hasher.finalize();

    // Check first 32 bytes match the hash
    if proof_bytes.len() >= 32 && proof_bytes[..32] != expected_hash[..] {
        return Err(ProverError::VerificationError(
            "Proof verification failed: invalid proof structure".to_string(),
        ));
    }

    // In production, this would:
    // 1. Load VerifyingKey from vk_hash
    // 2. Call verify_proof(vk, params, public_inputs, proof_bytes) with transcript
    // 3. Return true/false based on cryptographic verification

    Ok(true)
}

/// Batch verify multiple proofs (parallel verification)
///
/// # Arguments
///
/// * `proofs` - Vector of proofs to verify
/// * `config` - Prover configuration
///
/// # Returns
///
/// Vector of booleans indicating which proofs are valid
pub async fn batch_verify(proofs: Vec<&ProofOutput>, config: &ProverConfig) -> Result<Vec<bool>> {
    if config.parallel {
        // Parallel verification using tokio tasks instead of rayon
        let mut tasks = Vec::new();
        for proof in proofs {
            let proof_clone = proof.clone();
            let config_clone = config.clone();
            tasks.push(tokio::spawn(async move {
                verify(&proof_clone, &config_clone).await.unwrap_or(false)
            }));
        }
        
        let mut results = Vec::new();
        for task in tasks {
            results.push(task.await.unwrap_or(false));
        }
        Ok(results)
    } else {
        // Sequential verification
        let mut results = Vec::new();
        for proof in proofs {
            results.push(verify(proof, config).await?);
        }
        Ok(results)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{ProofOutput, TraceInfo};

    #[tokio::test]
    async fn test_verify_valid_proof() {
        use sha2::{Digest, Sha256};
        use halo2_proofs::pasta::Fp;

        // Create a valid proof structure - must match verifier's parsing
        let public_inputs_str = vec!["0x7b".to_string()]; // 123 in hex
        
        // Parse exactly as the verifier does
        let public_inputs_fp: Vec<Fp> = public_inputs_str
            .iter()
            .map(|s| {
                let val = s.trim_matches(|c| c == '0' || c == 'x');
                Fp::from(val.parse::<u64>().unwrap_or(0))
            })
            .collect();
        
        // Generate expected hash
        let mut hasher = Sha256::new();
        for input in &public_inputs_fp {
            hasher.update(format!("{:?}", input).as_bytes());
        }
        let hash = hasher.finalize();
        
        // Create proof with hash
        let mut proof_bytes = vec![0u8; 256];
        proof_bytes[..32].copy_from_slice(&hash);
        
        let proof = ProofOutput {
            proof: general_purpose::STANDARD.encode(&proof_bytes),
            public_inputs: public_inputs_str,
            metadata: TraceInfo {
                opcode_count: 3,
                gas_used: 9,
                tx_hash: None,
                block_number: None,
            },
            vk_hash: "vk_17".to_string(),
        };

        let config = ProverConfig::default();
        let result = verify(&proof, &config).await;
        assert!(result.is_ok());
        assert!(result.unwrap());
    }

    #[tokio::test]
    async fn test_verify_invalid_vk_hash() {
        let proof = ProofOutput {
            proof: general_purpose::STANDARD.encode(&vec![0u8; 128]),
            public_inputs: vec!["0x3".to_string()],
            metadata: TraceInfo {
                opcode_count: 3,
                gas_used: 9,
                tx_hash: None,
                block_number: None,
            },
            vk_hash: "wrong_vk".to_string(),
        };

        let config = ProverConfig::default();
        let result = verify(&proof, &config).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_verify_proof_too_short() {
        let proof = ProofOutput {
            proof: general_purpose::STANDARD.encode(&vec![0u8; 32]), // Too short
            public_inputs: vec!["0x3".to_string()],
            metadata: TraceInfo {
                opcode_count: 3,
                gas_used: 9,
                tx_hash: None,
                block_number: None,
            },
            vk_hash: "vk_17".to_string(),
        };

        let config = ProverConfig::default();
        let result = verify(&proof, &config).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_batch_verify() {
        use sha2::{Digest, Sha256};
        use halo2_proofs::pasta::Fp;

        let public_inputs_str = vec!["0x3".to_string()];
        
        // Parse exactly as the verifier does
        let public_inputs_fp: Vec<Fp> = public_inputs_str
            .iter()
            .map(|s| {
                let val = s.trim_matches(|c| c == '0' || c == 'x');
                Fp::from(val.parse::<u64>().unwrap_or(0))
            })
            .collect();

        let mut hasher = Sha256::new();
        for input in &public_inputs_fp {
            hasher.update(format!("{:?}", input).as_bytes());
        }
        let hash = hasher.finalize();
        
        let mut proof_bytes = vec![0u8; 256];
        proof_bytes[..32].copy_from_slice(&hash);

        let proof1 = ProofOutput {
            proof: general_purpose::STANDARD.encode(&proof_bytes),
            public_inputs: public_inputs_str.clone(),
            metadata: TraceInfo {
                opcode_count: 3,
                gas_used: 9,
                tx_hash: None,
                block_number: None,
            },
            vk_hash: "vk_17".to_string(),
        };

        let proof2 = proof1.clone();

        let config = ProverConfig::default();
        let results = batch_verify(vec![&proof1, &proof2], &config).await;
        assert!(results.is_ok());
        assert_eq!(results.unwrap(), vec![true, true]);
    }

    #[tokio::test]
    async fn test_batch_verify_sequential() {
        use sha2::{Digest, Sha256};
        use halo2_proofs::pasta::Fp;

        let public_inputs_fp = vec![Fp::from(5u64)];
        let mut hasher = Sha256::new();
        for input in &public_inputs_fp {
            hasher.update(format!("{:?}", input).as_bytes());
        }
        let hash = hasher.finalize();
        
        let mut proof_bytes = vec![0u8; 256];
        proof_bytes[..32].copy_from_slice(&hash);

        let proof = ProofOutput {
            proof: general_purpose::STANDARD.encode(&proof_bytes),
            public_inputs: vec!["0x5".to_string()],
            metadata: TraceInfo {
                opcode_count: 2,
                gas_used: 6,
                tx_hash: None,
                block_number: None,
            },
            vk_hash: "vk_17".to_string(),
        };

        let config = ProverConfig {
            parallel: false,
            ..Default::default()
        };
        
        let results = batch_verify(vec![&proof], &config).await;
        assert!(results.is_ok());
    }

    #[tokio::test]
    async fn test_verify_invalid_base64() {
        let proof = ProofOutput {
            proof: "not-valid-base64!@#$".to_string(),
            public_inputs: vec!["0x3".to_string()],
            metadata: TraceInfo {
                opcode_count: 3,
                gas_used: 9,
                tx_hash: None,
                block_number: None,
            },
            vk_hash: "vk_17".to_string(),
        };

        let config = ProverConfig::default();
        let result = verify(&proof, &config).await;
        assert!(result.is_err());
    }
}
